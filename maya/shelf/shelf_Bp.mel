global proc shelf_Bp () {
    global string $gBuffStr;
    global string $gBuffStr0;
    global string $gBuffStr1;


    shelfButton
        -enableCommandRepeat 1
        -flexibleWidthType 3
        -flexibleWidthValue 32
        -enable 1
        -width 35
        -height 34
        -manage 1
        -visible 1
        -preventOverride 0
        -annotation "import importlib\n\nfrom SaveAs import SaveAs\nimportlib.reload(SaveAs)\n\nfrom SaveAs import ExecuteDepartment\nimportlib.reload(ExecuteDepartment)\n\nfrom SaveAs import IconLoader\nimportlib.reload(IconLoader)\n\nfrom SaveAs import DlgAskVariation\nimportlib.reload(DlgAskVariation)\n\nfrom SaveAs import DlgAskAnimSettings\nimportlib.reload(DlgAskAnimSettings)\n\nfrom SaveAs import DlgAskCharacterName\nimportlib.reload(DlgAskCharacterName)\n\nSaveAs.main()" 
        -enableBackground 0
        -backgroundColor 0 0 0 
        -highlightColor 0.321569 0.521569 0.65098 
        -align "center" 
        -label "SaveAs" 
        -labelOffset 0
        -rotation 0
        -flipX 0
        -flipY 0
        -useAlpha 1
        -font "plainLabelFont" 
        -overlayLabelColor 0.8 0.8 0.8 
        -overlayLabelBackColor 0 0 0 0.5 
        -image "C:/Users/3D5/Documents/maya/2025/prefs/icons/home.png" 
        -image1 "C:/Users/3D5/Documents/maya/2025/prefs/icons/home.png" 
        -style "iconOnly" 
        -marginWidth 0
        -marginHeight 1
        -command "import importlib\n\nfrom SaveAs import SaveAs\nimportlib.reload(SaveAs)\n\nfrom SaveAs import ExecuteDepartment\nimportlib.reload(ExecuteDepartment)\n\nfrom SaveAs import IconLoader\nimportlib.reload(IconLoader)\n\nfrom SaveAs import DlgAskVariation\nimportlib.reload(DlgAskVariation)\n\nfrom SaveAs import DlgAskAnimSettings\nimportlib.reload(DlgAskAnimSettings)\n\nfrom SaveAs import DlgAskCharacterName\nimportlib.reload(DlgAskCharacterName)\n\nSaveAs.main()" 
        -sourceType "python" 
        -commandRepeatable 1
        -flat 1
    ;
    shelfButton
        -enableCommandRepeat 1
        -flexibleWidthType 3
        -flexibleWidthValue 32
        -enable 1
        -width 35
        -height 34
        -manage 1
        -visible 1
        -preventOverride 0
        -annotation "import PrismInit\n\nfrom PySide6 import QtWidgets, QtGui, QtCore\nfrom PySide6.QtCore import *\nfrom PySide6.QtGui import *\nfrom PySide6.QtWidgets import *\n\nimport os\nimport json\nfrom functools import partial\n\n\nimport maya.OpenMayaUI as omui\nfrom maya.app.general.mayaMixin import MayaQWidgetDockableMixin\nimport maya.cmds as cmds\nfrom maya.OpenMayaUI import MQtUtil\nimport ufe\n\ndef maya_main_window():\n    return None\n\n# Define some colors for bookmarks\ncolors = {\n    \"red\": \"#FF0000\",\n    \"pink\": \"#FF00FF\",\n    \"purple\": \"#800080\",\n    \"deep_purple\": \"#673AB7\",\n    \"indigo\": \"#3F51B5\",\n    \"blue\": \"#2196F3\",\n    \"light_blue\": \"#03A9F4\",\n    \"cyan\": \"#00BCD4\",\n    \"teal\": \"#009688\",\n    \"green\": \"#4CAF50\",\n    \"light_green\": \"#8BC34A\",\n    \"lime\": \"#CDDC39\",\n    \"yellow\": \"#FFEB3B\",\n    \"amber\": \"#FFC107\",\n    \"orange\": \"#FF9800\",\n    \"deep_orange\": \"#FF5722\",\n    \"brown\": \"#795548\",\n}\n\n\n# The navigator is a list widget displayed on the left side of the asset browser\n# It contains shortcuts to different asset categories and bookmarks\nclass NavigatorListWidget(QtWidgets.QListWidget):\n    def __init__(self,core, parent=None):\n        super().__init__(parent)\n        self.core = core\n        self.setObjectName(\"Navigator\")\n        \n        # Référence vers le widget parent pour accéder aux méthodes de bookmarks\n        self.parent_widget = None\n        \n        # Configurer le menu contextuel\n        self.setContextMenuPolicy(QtCore.Qt.CustomContextMenu)\n        self.customContextMenuRequested.connect(self.show_context_menu)\n        \n        # Title tree widget\n        title = QtWidgets.QListWidgetItem(\"Quick Navigator\")\n        title.setFlags(QtCore.Qt.NoItemFlags)\n        title.setTextAlignment(QtCore.Qt.AlignCenter)\n        title.setSizeHint(QtCore.QSize(0, 40))\n        self.addItem(title)\n\n        # self.addItems([\"Chars\", \"Items\" , \"Props\" , \"Modules\"])\n\n        bold_font = QtGui.QFont()\n        bold_font.setBold(True)\n\n\n        self.item_chars = QtWidgets.QListWidgetItem(\"Chars\")\n        self.item_chars.setIcon( self.core.getPlugin(\"Badger_Pipeline\").getIcon(\"char.png\"))\n        self.item_chars.setFont(bold_font)\n        self.addItem(self.item_chars)\n        # Set the current_path to \"Chars\"\n\n        self.item_items = QtWidgets.QListWidgetItem(\"Items\")\n        self.item_items.setIcon( self.core.getPlugin(\"Badger_Pipeline\").getIcon(\"item.png\"))\n        self.item_items.setFont(bold_font)\n        self.addItem(self.item_items)\n        # Set the current_path to \"Items\"\n\n        self.item_props = QtWidgets.QListWidgetItem(\"Props\")\n        self.item_props.setIcon( self.core.getPlugin(\"Badger_Pipeline\").getIcon(\"prop.png\"))\n        self.item_props.setFont(bold_font)\n        self.addItem(self.item_props)\n        # Set the current_path to \"Props\"\n\n        self.item_modules = QtWidgets.QListWidgetItem(\"Modules\")\n        self.item_modules.setIcon( self.core.getPlugin(\"Badger_Pipeline\").getIcon(\"module_2.png\"))\n        self.item_modules.setFont(bold_font)\n        self.addItem(self.item_modules)\n        # Set the current_path to \"Modules\"\n\n        self.setMinimumWidth(150)\n    \n    \n        # Add a separator\n        separator = QtWidgets.QListWidgetItem(self)\n        separator.setFlags(QtCore.Qt.NoItemFlags)\n        separator.setSizeHint(QtCore.QSize(0, 15))\n\n        # Add a title for \"Bookmarks\"\n        self.bookmarks_title = QtWidgets.QListWidgetItem(\"Bookmarks\")\n        self.bookmarks_title.setFlags(QtCore.Qt.NoItemFlags)\n        self.bookmarks_title.setTextAlignment(QtCore.Qt.AlignCenter)\n        self.bookmarks_title.setSizeHint(QtCore.QSize(0, 40))\n        self.addItem(self.bookmarks_title)\n\n        # Crées les bookmarks\n        for color in colors.keys():\n            color_item = QtWidgets.QListWidgetItem(color)\n            color_item.setIcon(self.core.getPlugin(\"Badger_Pipeline\").getIcon(\"collection_\" + color + \".png\"))\n            color_item.setData(QtCore.Qt.UserRole, {\"type\": \"bookmark_color\", \"color\": color})\n            self.addItem(color_item)\n\n        # Connect itemClicked to slot\n        self.itemClicked.connect(self.on_nav_item_clicked)\n\n\n    def set_items_list_widget(self, items_list_widget):\n        self.items_list_widget = items_list_widget\n\n    def set_parent_widget(self, parent_widget):\n        \"\"\"Définit le widget parent pour accéder aux méthodes de bookmarks\"\"\"\n        self.parent_widget = parent_widget\n\n    def refresh_bookmarks(self):\n        \"\"\"Rafraîchit l'affichage des bookmarks\"\"\"\n        if not self.parent_widget:\n            return\n         \n\n    def show_context_menu(self, position):\n        \"\"\"Affiche le menu contextuel pour les bookmarks\"\"\"\n        item = self.itemAt(position)\n        if not item:\n            return\n            \n        item_data = item.data(QtCore.Qt.UserRole)\n        if not item_data:\n            return\n            \n        menu = QtWidgets.QMenu(self)\n        \n        if item_data.get(\"type\") == \"bookmark_asset\":\n            # Menu pour un asset bookmarké\n            entity = item_data.get(\"entity\")\n            color = item_data.get(\"color\")\n            \n            remove_action = menu.addAction(f\"Supprimer du bookmark {color}\")\n            remove_action.triggered.connect(partial(self.remove_bookmark_asset, entity, color))\n            \n            navigate_action = menu.addAction(\"Naviguer vers cet asset\")\n            navigate_action.triggered.connect(partial(self.navigate_to_asset, entity))\n            \n        elif item_data.get(\"type\") == \"bookmark_color\":\n            # Menu pour une couleur de bookmark\n            color = item_data.get(\"color\")\n            \n            clear_action = menu.addAction(f\"Vider tous les bookmarks {color}\")\n            clear_action.triggered.connect(partial(self.clear_color_bookmarks, color))\n        \n        if menu.actions():  # Seulement afficher le menu s'il y a des actions\n            menu.exec_(self.mapToGlobal(position))\n\n    def remove_bookmark_asset(self, entity, color):\n        \"\"\"Supprime un asset des bookmarks\"\"\"\n        if self.parent_widget:\n            success = self.parent_widget.remove_from_bookmark(entity, color)\n            if success:\n                QtWidgets.QMessageBox.information(self, \"Bookmark\", f\"Asset supprimé des bookmarks {color}\")\n\n    def clear_color_bookmarks(self, color):\n        \"\"\"Vide tous les bookmarks d'une couleur\"\"\"\n        if not self.parent_widget:\n            return\n            \n        reply = QtWidgets.QMessageBox.question(\n            self, \n            \"Confirmer\", \n            f\"Êtes-vous sûr de vouloir supprimer tous les bookmarks {color} ?\",\n            QtWidgets.QMessageBox.Yes | QtWidgets.QMessageBox.No\n        )\n        \n        if reply == QtWidgets.QMessageBox.Yes:\n            bookmarks = self.parent_widget.get_bookmarks()\n            bookmarks[color] = []\n            self.parent_widget.save_bookmarks(bookmarks)\n            self.refresh_bookmarks()\n\n    def navigate_to_asset(self, entity):\n        \"\"\"Navigue vers l'asset dans la liste principale\"\"\"\n        if not self.items_list_widget:\n            return\n            \n        asset_path = entity.get('asset_path', '')\n        if not asset_path:\n            return\n            \n        # Extraire le chemin du dossier et le nom de l'asset\n        asset_splited = asset_path.replace(\"\\\\\", \"/\").split(\"/\")\n        if len(asset_splited) > 1:\n            folder_path = \"/\".join(asset_splited[:-1])\n        else:\n            folder_path = \"\"\n            \n        # Naviguer vers le dossier approprié\n        self.items_list_widget.set_current_path(folder_path)\n\n    def on_nav_item_clicked(self, item):\n        nav_names = [\"Chars\", \"Items\", \"Props\", \"Modules\"]\n        if item.text() in nav_names and hasattr(self, \"items_list_widget\"):\n            self.parent_widget.search_bar.setText(\"\")\n            self.items_list_widget.set_filter(\"\")\n            self.items_list_widget.set_current_path(item.text())\n        \n        # Gérer les clics sur les bookmarks\n        item_data = item.data(QtCore.Qt.UserRole)\n        print(item_data)\n        if item_data and item_data.get(\"type\") == \"bookmark_color\":\n            # set @<color> as a filter in the search bar of the parent widget\n            color = item_data.get(\"color\")\n            if self.parent_widget:\n                self.parent_widget.search_bar.setText(f\"@{color}\")\n                # Refresh the items list\n                self.items_list_widget.set_filter_and_ui(f\"@{color}\")\n\n# The items list is a QListWidget that displays the assets in the main area of the asset browser\nclass ItemsListWidget(QtWidgets.QListWidget):\n\n    def __init__(self, core, parent=None):\n        super().__init__(parent)\n        self.core = core\n        self.setObjectName(\"Items\")\n        self.addItems([\"01_Assets\", \"02_Shots\"])\n        self.setMinimumWidth(300)\n\n        self.itemDoubleClicked.connect(self.onItemDoubleClicked)\n\n        # Modes: 'list' or 'grid'\n        self._view_mode = 'list'\n        self.set_list_mode()\n\n        # Ajout des attributs current_path et filter\n        self._current_path = \"\"\n        self._filter = \"\"\n\n        # Référence vers le widget parent pour accéder aux méthodes de bookmarks\n        self.parent_widget = None\n\n        # Configurer le menu contextuel\n        self.setContextMenuPolicy(QtCore.Qt.CustomContextMenu)\n        self.customContextMenuRequested.connect(self.show_context_menu)\n\n        # Fill the database with assets from the core\n        self.fill_assets()\n\n\n    # Getter/setter pour current_path\n    def get_current_path(self):\n        return self._current_path\n\n    def set_current_path(self, path):\n        self._current_path = path\n        self.fill_assets()\n\n    # Getter/setter pour filter\n    def get_filter(self):\n        return self._filter\n\n    def set_filter(self, filter_str):\n        self._filter = filter_str\n        self.fill_assets()\n\n    def set_filter_and_ui(self, filter_str):\n        self._filter = filter_str\n        self.fill_assets()\n\n    # Fonction pour remonter d'un dossier\n    def go_up(self):\n        if self._current_path:\n            parts = self._current_path.rstrip(\"/\\\\\").split(\"/\" if \"/\" in self._current_path else \"\\\\\")\n            if len(parts) > 1:\n                self._current_path = \"/\".join(parts[:-1])\n            else:\n                self._current_path = \"\"\n            self.fill_assets()\n        else:\n            # Déjà à la racine\n            pass\n\n    # Fill the database with assets from the core\n    def fill_assets(self):\n        \"\"\"\n        Remplit la liste d'assets en fonction du current_path et du filtre.\n        Structure attendue de getAssets():\n        [\n            {\n                \"type\": \"asset\",\n                \"asset_path\": \"Chars\\\\AAA\"\n            },\n            ...\n        ]\n        \"\"\"\n\n        self.clear()\n        assets = self.core.entities.getAssets()\n        filtered_assets = []\n        folders = []\n\n\n        # Si le filtre commence par @, on cherche dans les bookmarks\n        if self._filter.startswith(\"@\") and self.parent_widget:\n            bookmark_color = self._filter[1:]  # Couleur sans le @\n            bookmarks = self.parent_widget.get_bookmarks()\n            bookmarked_entities = bookmarks.get(bookmark_color, [])\n            for entity in bookmarked_entities:\n                item = QtWidgets.QListWidgetItem(entity['asset_path'])\n                name = entity['asset_path'].split(\"/\")[-1].split(\"\\\\\")[-1]\n                item.setText(name)\n                item.setWhatsThis(\"asset\")\n                item.setToolTip(json.dumps(entity, indent=4))\n                icon_path = self.core.entities.getEntityPreviewPath(entity)\n                # if the file exists\n                if icon_path and os.path.exists(icon_path):\n                    item.setIcon(QtGui.QIcon(icon_path))\n                else:\n                    item.setIcon(self.core.getPlugin(\"Badger_Pipeline\").getIcon(\"noFileSmall.png\"))\n\n                # Store entity and color in UserRole for context menu\n                item.setData(QtCore.Qt.UserRole, {\"type\": \"bookmark_asset\", \"entity\": entity, \"color\": bookmark_color})\n                \n                self.addItem(item)\n            return  # Exit after showing bookmarks\n\n\n        # Filtrage par current_path et filter\n        for asset in assets:\n            path = asset.get('asset_path', '')\n\n            # Asset name is the last part of the path,\n            # Asset path is the rest, if any\n            asset_splited = path.replace(\"\\\\\", \"/\").split(\"/\")\n            asset_path = \"\"\n            asset_name = \"\"\n\n            if len(asset_splited) > 1:\n                asset_name = asset_splited[-1]\n                asset_path = \"/\".join(asset_splited[:-1])\n            else:\n                asset_name = asset_splited[0]\n                asset_path = \"\"\n\n            # Collecte des dossiers enfants directs uniquement\n            if asset_path and asset_path != self._current_path:\n                # Normaliser les chemins pour éviter les problèmes de séparateurs\n                normalized_asset_path = asset_path.replace(\"\\\\\", \"/\")\n                normalized_current_path = self._current_path.replace(\"\\\\\", \"/\")\n                \n                # Vérifier si asset_path est un enfant direct de current_path\n                if normalized_current_path == \"\":\n                    # À la racine, prendre le premier niveau\n                    first_level = normalized_asset_path.split(\"/\")[0]\n                    if first_level not in folders:\n                        folders.append(first_level)\n                elif normalized_asset_path.startswith(normalized_current_path + \"/\"):\n                    # Extraire le niveau enfant direct\n                    relative_path = normalized_asset_path[len(normalized_current_path) + 1:]\n                    child_folder = relative_path.split(\"/\")[0]\n                    child_path = normalized_current_path + \"/\" + child_folder\n                    if child_path not in folders:\n                        folders.append(child_path)\n\n\n            # Filtrage par current_path\n            if asset_path != self._current_path:\n                continue\n\n            # Filtrage par filter\n            if self._filter:\n                if self._filter.lower() not in asset_name.lower():\n                    continue\n\n            \n\n            filtered_assets.append(asset)\n\n        # Creation des dossiers\n        for folder in folders:\n            item = QtWidgets.QListWidgetItem(folder)\n            name = folder.split(\"/\")[-1].split(\"\\\\\")[-1]\n            item.setText(name)\n            item.setIcon(self.core.getPlugin(\"Badger_Pipeline\").getIcon(\"folder.png\"))\n            item.setWhatsThis(\"folder\")\n            # Stocker le chemin complet du dossier dans les données de l'item\n            item.setData(QtCore.Qt.UserRole, {\"type\": \"folder\", \"full_path\": folder})\n            self.addItem(item)\n\n        # Création des assets\n        for asset in filtered_assets:\n            item = QtWidgets.QListWidgetItem(asset['asset_path'])\n            name = asset['asset_path'].split(\"/\")[-1].split(\"\\\\\")[-1]\n            item.setText(name)\n            item.setWhatsThis(\"asset\")\n            item.setToolTip(json.dumps(asset, indent=4))\n            icon_path = self.core.entities.getEntityPreviewPath(asset)\n            # if the file exists\n            if icon_path and os.path.exists(icon_path):\n                item.setIcon(QtGui.QIcon(icon_path))\n            else:\n                item.setIcon(self.core.getPlugin(\"Badger_Pipeline\").getIcon(\"noFileSmall.png\"))\n\n            \n            self.addItem(item)\n\n\n\n\n    # Switch to list mode\n    def set_list_mode(self):\n        self.setViewMode(QtWidgets.QListView.ListMode)\n        self.setIconSize(QtCore.QSize(24, 24))\n        self.setGridSize(QtCore.QSize(36, 36))\n        self._view_mode = 'list'\n\n    # Switch to grid mode\n    def set_grid_mode(self):\n        self.setViewMode(QtWidgets.QListView.IconMode)\n        self.setIconSize(QtCore.QSize(96, 96))\n        self.setGridSize(QtCore.QSize(110, 110))\n        self._view_mode = 'grid'\n\n    # Toggle between list and grid mode\n    def toggle_mode(self, mode):\n        if mode == 'list':\n            self.set_list_mode()\n        elif mode == 'grid':\n            self.set_grid_mode()\n\n    # When an item is double clicked\n    # @todo : Create the corresponding houdini node\n    def onItemDoubleClicked(self, item):\n        # Vérifie si l'item est un dossier via whatsThis\n        if item.whatsThis() == \"folder\":\n            # Récupérer le chemin complet depuis les données de l'item\n            item_data = item.data(QtCore.Qt.UserRole)\n            if item_data and item_data.get(\"type\") == \"folder\":\n                folder_path = item_data.get(\"full_path\")\n                if folder_path:\n                    self.set_current_path(folder_path)\n                    return\n            \n            # Fallback vers l'ancienne méthode si les données ne sont pas disponibles\n            folder_name = item.text()\n            if self._current_path:\n                new_path = self._current_path + \"/\" + folder_name\n            else:\n                new_path = folder_name\n            self.set_current_path(new_path)\n            return\n        \n\n        # The item is an asset. Create a corresponding houdini node\n        asset = json.loads(item.toolTip())\n        products = self.core.products.getProductsFromEntity(asset)\n        for product in products:\n            if \"USD_Asset\" in product[\"product\"]:\n                product_path = product[\"path\"]\n                product_path = product_path.replace(\"\\\\\", \"/\")\n                product_path = os.path.join(product_path, \"asset.usda\")\n\n                # Check if the file exists\n                if not os.path.exists(product_path):\n                    QtWidgets.QMessageBox.warning(self, \"File Not Found\", f\"The USD file does not exist:\\n{product_path}\")\n                    return\n\n                # Create the asset_name\n                asset_name = asset['asset_path'].split(\"/\")[-1].split(\"\\\\\")[-1]\n                print(\"Asset name:\", asset_name)\n\n                # Create a \"assetreference\" node named after the asset's name\n                print(\"Importing asset:\", product_path)\n                print(product)\n\n                # Get the maya selection\n                import mayaUsd.ufe as mayaUsdUfe\n    \n                # Find all mayaUsdProxyShape nodes in the scene\n                usd_nodes = cmds.ls(type=\"mayaUsdProxyShape\")\n                \n                if not usd_nodes:\n                    print(\"No USD stages found in the scene\")\n                    return None, None\n                \n                # Get the first node and its stage\n                first_node = usd_nodes[0]\n                node_long = cmds.ls(first_node, long=True)[0]\n\n                selection = ufe.GlobalSelection.get()\n                selected_path = \"\"\n                # Itérer sur les éléments sélectionnés\n                for item in selection:\n                    path = item.path()\n                    if(\"/\" in str(path)):\n                        # Take everything after the first \"/\" (/ included : /SetDress/AAA -> SetDress)\n                        selected_path = str(path).split(\"/\", 1)[1]\n                        \n\n                        break\n\n                try:\n                    stage = mayaUsdUfe.getStage(node_long)\n\n                    # Check if there is a selected path\n                    if selected_path:\n                        path = \"/\" + selected_path + \"/\" + asset_name\n                    else:\n                        path = \"/SetDress/\" + asset_name\n                    # If the prim already exist, we add a number at the end\n                    if stage.GetPrimAtPath(path).IsValid():\n                        i = 1\n                        while stage.GetPrimAtPath(path + str(i)).IsValid():\n                            i += 1\n                        path = path + str(i)\n                    xform = stage.DefinePrim(path, \"Xform\")\n                    xform.GetReferences().AddReference(product_path)\n\n                    print(f\"Found USD stage: {first_node}\")\n                    return stage, first_node\n                except Exception as e:\n                    print(f\"Error getting stage from node {first_node}: {e}\")\n                    return None, None\n\n\n    def set_parent_widget(self, parent_widget):\n        \"\"\"Définit le widget parent pour accéder aux méthodes de bookmarks\"\"\"\n        self.parent_widget = parent_widget\n\n    def show_context_menu(self, position):\n        \"\"\"Affiche le menu contextuel\"\"\"\n        item = self.itemAt(position)\n        if not item or item.whatsThis() != \"asset\":\n            return\n\n        # Récupérer l'entité depuis le tooltip\n        try:\n            entity = json.loads(item.toolTip())\n        except:\n            return\n\n        menu = QtWidgets.QMenu(self)\n        \n        # Vérifier si l'asset est déjà bookmarké\n        current_bookmark_color = None\n        if self.parent_widget:\n            current_bookmark_color = self.parent_widget.is_bookmarked(entity)\n\n        if current_bookmark_color:\n            # Si déjà bookmarké, proposer de le supprimer\n            remove_action = menu.addAction(f\"Supprimer du bookmark {current_bookmark_color}\")\n            remove_action.triggered.connect(partial(self.remove_from_bookmark, entity, current_bookmark_color))\n            menu.addSeparator()\n\n        # Sous-menu pour ajouter aux bookmarks\n        bookmark_menu = menu.addMenu(\"Ajouter aux bookmarks\")\n        \n        for color_name, color_value in colors.items():\n            action = bookmark_menu.addAction(color_name)\n            \n            # Créer une icône colorée pour chaque couleur\n            pixmap = QtGui.QPixmap(16, 16)\n            pixmap.fill(QtGui.QColor(color_value))\n            icon = QtGui.QIcon(pixmap)\n            action.setIcon(icon)\n            \n            # Si l'asset est déjà dans cette couleur, griser l'option\n            if self.parent_widget:\n                bookmarks = self.parent_widget.get_bookmarks()\n                if entity in bookmarks.get(color_name, []):\n                    action.setEnabled(False)\n                    action.setText(f\"{color_name} (déjà ajouté)\")\n\n            \n            action.triggered.connect(partial(self.add_to_bookmark, entity, color_name))\n\n        menu.exec_(self.mapToGlobal(position))\n\n    def add_to_bookmark(self, entity, color):\n        \"\"\"Ajoute l'entité aux bookmarks\"\"\"\n        if self.parent_widget:\n            success = self.parent_widget.add_to_bookmark(entity, color)\n            if success:\n                QtWidgets.QMessageBox.information(self, \"Bookmark\", f\"Asset ajouté aux bookmarks {color}\")\n            else:\n                QtWidgets.QMessageBox.warning(self, \"Bookmark\", f\"Asset déjà présent dans les bookmarks {color}\")\n\n    def remove_from_bookmark(self, entity, color):\n        \"\"\"Supprime l'entité des bookmarks\"\"\"\n        if self.parent_widget:\n            success = self.parent_widget.remove_from_bookmark(entity, color)\n            if success:\n                QtWidgets.QMessageBox.information(self, \"Bookmark\", f\"Asset supprimé des bookmarks {color}\")\n            else:\n                QtWidgets.QMessageBox.warning(self, \"Bookmark\", f\"Asset non trouvé dans les bookmarks {color}\")\n                    \n\n# The main widget that contains the navigator and the items list\nclass ProjectBrowserWidget(MayaQWidgetDockableMixin, QtWidgets.QDialog):\n    def __init__(self, core , parent=None):\n        super(ProjectBrowserWidget, self).__init__(parent)\n        self.core = core\n        self.setWindowFlags(self.windowFlags() ^ QtCore.Qt.WindowContextHelpButtonHint)\n\n        self.setWindowTitle(\"Asset Browser\")\n\n        # Layout principal vertical\n        main_layout = QtWidgets.QVBoxLayout(self)\n        main_layout.setContentsMargins(8, 8, 8 ,8)\n\n        # --- Search bar + mode button ---\n        search_layout = QtWidgets.QHBoxLayout()\n\n        # Mode button\n        self.mode_button = QtWidgets.QPushButton(\"\", self)\n        self.mode_button.setIcon(self.core.getPlugin(\"Badger_Pipeline\").getIcon(\"menu.png\"))\n        search_layout.addWidget(self.mode_button)\n\n        # QMenu for mode selection\n        self.mode_menu = QtWidgets.QMenu(self)\n        self.action_list = self.mode_menu.addAction(\"Liste\")\n        self.action_grid = self.mode_menu.addAction(\"Grille\")\n        # Les items sont créés plus bas, donc on connecte après\n\n        # Up button\n        self.up_button = QtWidgets.QPushButton(\"\", self)\n        self.up_button.setIcon(self.core.getPlugin(\"Badger_Pipeline\").getIcon(\"up.png\"))\n        search_layout.addWidget(self.up_button)\n\n        # Search bar\n        self.search_bar = QtWidgets.QLineEdit(self)\n        self.search_bar.setPlaceholderText(\"Rechercher...\")\n        search_layout.addWidget(self.search_bar)\n\n        # Clear button\n        self.clear_button = QtWidgets.QPushButton(\"\", self)\n        self.clear_button.setIcon(self.core.getPlugin(\"Badger_Pipeline\").getIcon(\"backspace.png\"))\n        search_layout.addWidget(self.clear_button)\n        main_layout.addLayout(search_layout)\n\n        # --- Splitter ---\n        splitter = QtWidgets.QSplitter(QtCore.Qt.Horizontal)\n        self.items = ItemsListWidget(core)\n        self.navigator = NavigatorListWidget(core)\n        self.navigator.set_items_list_widget(self.items)\n        \n        # Connecter l'ItemsListWidget au widget parent pour les bookmarks\n        self.items.set_parent_widget(self)\n        \n        # Connecter le NavigatorListWidget au widget parent pour les bookmarks\n        self.navigator.set_parent_widget(self)\n        \n        splitter.addWidget(self.navigator)\n        splitter.addWidget(self.items)\n        splitter.setStretchFactor(0, 0)\n        splitter.setStretchFactor(1, 1)\n        main_layout.addWidget(splitter)\n\n        # Connect mode actions après création de self.items\n        self.action_list.triggered.connect(lambda: self.items.toggle_mode('list'))\n        self.action_grid.triggered.connect(lambda: self.items.toggle_mode('grid'))\n        self.mode_button.setMenu(self.mode_menu)\n\n        # Connect bouton up à go_up\n        self.up_button.clicked.connect(lambda: self.items.go_up())\n        # Connect clear button\n        self.clear_button.clicked.connect(self.search_bar.clear)\n        # Connecte la barre de recherche au filtre\n        self.search_bar.textChanged.connect(lambda text: self.items.set_filter(text))\n\n        # Initialiser les bookmarks\n        self.navigator.refresh_bookmarks()\n\n        print(\"Bookmarks loaded:\", self.get_bookmarks())\n\n    # Show window with docking ability\n    def run(self):\n        self.show(dockable=True)\n\n\n    def on_up_clicked(self):\n        # Navigue vers le dossier parent dans ItemsListWidget\n        self.items.go_up()\n\n    def get_bookmarks_file_path(self):\n        \"\"\"Retourne le chemin vers le fichier bookmarks.json\"\"\"\n        pipeline_path = self.core.projects.getResolvedProjectStructurePath(\"pipeline\" , context = {})\n        return os.path.join(pipeline_path, \"bookmarks.json\")\n\n    def get_bookmarks(self):\n        \"\"\"Charge les bookmarks depuis le fichier JSON\"\"\"\n        bookmarks_path = self.get_bookmarks_file_path()\n        \n        # If the file does not exist, create it with an empty list, \n        if not os.path.exists(bookmarks_path):\n            \n            empty_data = {\n                \"bookmarks\" : {}\n            }\n            for color in colors.keys():\n                empty_data[\"bookmarks\"][color] = []\n\n            with open(bookmarks_path, 'w') as f:\n                json.dump(empty_data, f, indent=4)\n\n        # Load bookmarks from the JSON file\n        with open(bookmarks_path, 'r') as f:\n            data = json.load(f)\n\n        return data.get(\"bookmarks\", {})\n\n    def save_bookmarks(self, bookmarks_data):\n        \"\"\"Sauvegarde les bookmarks dans le fichier JSON\"\"\"\n        bookmarks_path = self.get_bookmarks_file_path()\n        \n        data = {\n            \"bookmarks\": bookmarks_data\n        }\n        \n        with open(bookmarks_path, 'w') as f:\n            json.dump(data, f, indent=4)\n\n    def add_to_bookmark(self, entity, color):\n        \"\"\"Ajoute une entité aux bookmarks d'une couleur donnée\"\"\"\n        bookmarks = self.get_bookmarks()\n        \n        # Vérifier si l'entité n'est pas déjà dans cette couleur\n        if entity not in bookmarks.get(color, []):\n            bookmarks.setdefault(color, []).append(entity)\n            self.save_bookmarks(bookmarks)\n            # Rafraîchir l'affichage des bookmarks\n            self.navigator.refresh_bookmarks()\n            return True\n        return False\n\n    def remove_from_bookmark(self, entity, color):\n        \"\"\"Supprime une entité des bookmarks d'une couleur donnée\"\"\"\n        bookmarks = self.get_bookmarks()\n        \n        if color in bookmarks and entity in bookmarks[color]:\n            bookmarks[color].remove(entity)\n            self.save_bookmarks(bookmarks)\n            # Rafraîchir l'affichage des bookmarks\n            self.navigator.refresh_bookmarks()\n            return True\n        return False\n\n    def is_bookmarked(self, entity):\n        \"\"\"Vérifie si une entité est dans les bookmarks et retourne la couleur, sinon None\"\"\"\n        bookmarks = self.get_bookmarks()\n        for color, entities in bookmarks.items():\n            if entity in entities:\n                return color\n        return None\n\n\n# Create and return the main interface widget\n# Entry point used by Houdini\ndef createInterface():\n    try:\n        core = PrismInit.pcore\n        return ProjectBrowserWidget(core)\n\n    except Exception as e:\n        print(f\"Error initializing PrismInit: {e}\")\n        return QtWidgets.QLabel(\"Error initializing PrismInit\")\n    \nif __name__ == \"__main__\":\n    window = createInterface()\n    window.run()" 
        -enableBackground 0
        -backgroundColor 0 0 0 
        -highlightColor 0.321569 0.521569 0.65098 
        -align "center" 
        -label "AssetBrowser" 
        -labelOffset 0
        -rotation 0
        -flipX 0
        -flipY 0
        -useAlpha 1
        -font "plainLabelFont" 
        -overlayLabelColor 0.8 0.8 0.8 
        -overlayLabelBackColor 0 0 0 0.5 
        -image "C:/Users/3D5/Documents/maya/2025/prefs/icons/import.png" 
        -image1 "C:/Users/3D5/Documents/maya/2025/prefs/icons/import.png" 
        -style "iconOnly" 
        -marginWidth 0
        -marginHeight 1
        -command "from asset_browser_window.asset_browser_window_maya import *\nwindow = createInterface()\nwindow.run()\n" 
        -sourceType "python" 
        -commandRepeatable 1
        -flat 1
    ;

} 
